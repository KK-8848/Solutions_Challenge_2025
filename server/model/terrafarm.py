# -*- coding: utf-8 -*-
"""Terrafarm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mD_aXg1p2uMWkDkvqVDTYjstUbd0hpbB
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import xgboost as xgb
import matplotlib.pyplot as plt
import seaborn as sns

# Load the data
data = pd.read_csv('data.csv')

# Feature engineering - create an afforestation suitability score based on domain knowledge
data['afforestation_score'] = (data['Average Annual Rainfall (inches)'] * 0.3 + data['Soil Suitability (0 to 1)'] * 0.4 + data['Wildlife Benefit Potential (0 to 1)'] * 0.2 - (data['Population'] / 1000000) * 0.1            )

data["afforestation_score"] = (data["afforestation_score"] - data["afforestation_score"].min()) / (data["afforestation_score"].max() - data["afforestation_score"].min())
data["good_for_afforestation"] = (data["afforestation_score"] > 0.6).astype(int)

# Select features for modeling
features = ['Average Annual Rainfall (inches)', 'Soil Suitability (0 to 1)',
           'Wildlife Benefit Potential (0 to 1)', 'Population']

X = data[features]
y = data['good_for_afforestation']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15, random_state=42)

# Standardize the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

for i in range(0,61):
  print(y[i])

xgb_model = xgb.XGBClassifier(
    max_depth=4,
    learning_rate=0.1,
    n_estimators=100,
    objective="binary:logistic",
    random_state=42,
)
xgb_model.fit(X_train_scaled, y_train)

# Make predictions
xgb_predictions = xgb_model.predict(X_test_scaled)

# Evaluate XGBoost model
print("\nXGBoost Model Results:")
print(f"Accuracy: {accuracy_score(y_test, xgb_predictions):.4f}")
print("\nClassification Report:")
print(classification_report(y_test, xgb_predictions))

# Function to get afforestation suitability by state
def get_afforestation_locations(state, model, features, scaler):
    """
    Input: State name
    Output: List of suitable locations for afforestation in the specified state.
    """
    state_data = data[data["State"] == state].copy()

    if state_data.empty:
        return f"No data available for {state}."

    # Prepare features for prediction
    X_state = state_data[features]
    X_state_scaled = scaler.transform(X_state)

    # Predict suitability
    predictions = model.predict(X_state_scaled)
    probabilities = model.predict_proba(X_state_scaled)[:, 1]  # Probability of class 1

    # Add predictions to the state data
    state_data["Prediction"] = predictions
    state_data["Probability"] = probabilities

    # Filter for good locations (Prediction == 1)
    good_locations = state_data[state_data["Prediction"] == 1]

    if good_locations.empty:
        return f"No suitable locations found for afforestation in {state}."

    # Return only the location names
    return good_locations[["City", "Probability"]].sort_values(by="Probability", ascending=False)

# Basic Input-Output system
def main():
    state_input = input("Enter the state you want to check for afforestation suitability: ")
    result = get_afforestation_locations(state_input, xgb_model, features, scaler)

    if isinstance(result, str):  # If the result is a message (e.g., "No data available")
        print(result)
    else:
        print(f"Suitable locations for afforestation in {state_input}:")
        for index, row in result.iterrows():
            print(f"- {row['City']} (Probability: {row['Probability']:.4f})")

def predict_afforestation_suitability(model):
    # Create a feature array for the new location
    rainfall = float(input("Enter rainfall in inches"))
    soil_suitability = float(input("Enter soil suitability (0 to 1)"))
    wildlife_potential = float(input("Enter wildlife potential (0 to 1)"))
    population = float(input("Enter population"))
    new_location = np.array(
        [[rainfall, soil_suitability, wildlife_potential, population]]
    )

    # Scale the features
    new_location_scaled = scaler.transform(new_location)

    # Make prediction
    prediction = model.predict(new_location_scaled)[0]
    probability = model.predict_proba(new_location_scaled)[0][1]

    if prediction == 1:
        suitability = "Good"
    else:
        suitability = "Not Good"

    return suitability, probability*100

main()

predict_afforestation_suitability(xgb_model)



